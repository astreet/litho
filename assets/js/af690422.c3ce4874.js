"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7485],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>m,MDXProvider:()=>d,mdx:()=>x,useMDXComponents:()=>c,withMDXComponents:()=>s});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var m=a.createContext({}),s=function(e){return function(t){var n=c(t.components);return a.createElement(e,i({},t,{components:n}))}},c=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(m.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),s=c(n),d=o,h=s["".concat(r,".").concat(d)]||s[d]||u[d]||i;return n?a.createElement(h,p(p({ref:t},m),{},{components:n})):a.createElement(h,p({ref:t},m))}));function x(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:o,r[1]=p;for(var m=2;m<i;m++)r[m]=n[m];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},96334:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>p,metadata:()=>m,toc:()=>c});var a=n(83117),o=n(80102),i=(n(67294),n(3905)),r=(n(44996),["components"]),p={id:"custom-layout",title:"Manual Measurement"},l=void 0,m={unversionedId:"custom-layout",id:"custom-layout",title:"Manual Measurement",description:"Litho relies on Yoga, a powerful layout engine that can create very complex UIs for layout calculations.  However, there are few exceptions where Yoga is not sufficient and you may need to implement your own measuring and layout logic.",source:"@site/../docs/custom-layout.md",sourceDirName:".",slug:"/custom-layout",permalink:"/docs/custom-layout",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/custom-layout.md",tags:[],version:"current",frontMatter:{id:"custom-layout",title:"Manual Measurement"}},s={},c=[{value:"Use Cases",id:"use-cases",level:2},{value:"Size Constraints",id:"size-constraints",level:2},{value:"Measuring a Component",id:"measuring-a-component",level:2},{value:"SizeSpec Information During Layout",id:"sizespec-information-during-layout",level:2},{value:"Kotlin Integration",id:"kotlin-integration",level:2}],d={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.mdx)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Litho relies on ",(0,i.mdx)("a",{parentName:"p",href:"https://yogalayout.com/docs/"},"Yoga"),", a powerful layout engine that can create very complex UIs for layout calculations.  However, there are few exceptions where Yoga is not sufficient and you may need to implement your own measuring and layout logic."),(0,i.mdx)("p",null,"Litho provides a manual component measurement API for determining component sizes during layout creation, which enables Developers to implement dynamic logic based on component sizes."),(0,i.mdx)("admonition",{title:"IMPORTANT",type:"caution"},(0,i.mdx)("p",{parentName:"admonition"}," This API comes with a ",(0,i.mdx)("strong",{parentName:"p"},"non-negligible")," performance overhead.\nLitho is built to optimise when a measure occurs for any component. Measuring a component with this API ends up performing additional measurements to the ones intrinsic to Litho's lifecycle. Measurement can become a heavy operation, especially with more complex layouts, so be sure to only utilize this API when absolutely necessary.")),(0,i.mdx)("h2",{id:"use-cases"},"Use Cases"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"A component layout tree depends on its own and/or children's size.")," For example, perhaps a component layout should use a child only if it fits within its size constraints. If the child doesn't fit, the layout should instead use another child as a fallback.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Children of a container must be absolutely positioned manually based on their/parent size.")," Yoga can absolutely position children in a parent. However, the position itself might depend on the child sizes after being measured using the parent size constraints. Margins or paddings need to be manually considered if required.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"This API should only be used during layout creation.")," Using the API elsewhere may cause unintended behaviour."))),(0,i.mdx)("h2",{id:"size-constraints"},"Size Constraints"),(0,i.mdx)("p",null,"Before diving into the API, it's recommended that you familiarise yourself with how the ",(0,i.mdx)("a",{parentName:"p",href:"https://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int)"},"onMeasure")," function works in a regular Android ",(0,i.mdx)("inlineCode",{parentName:"p"},"View"),".  Also,  what a ",(0,i.mdx)("a",{parentName:"p",href:"https://developer.android.com/reference/android/view/View.MeasureSpec.html"},"MeasureSpec")," is, since Litho uses an analogous concept called ",(0,i.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/SizeSpec.html"},"SizeSpec"),"."),(0,i.mdx)("p",null,"Similar to the Android ",(0,i.mdx)("inlineCode",{parentName:"p"},"MeasureSpec")," equivalent, Litho's ",(0,i.mdx)("inlineCode",{parentName:"p"},"SizeSpec")," is composed of a size and a mode. The possible modes, same as for ",(0,i.mdx)("inlineCode",{parentName:"p"},"MeasureSpec"),", are: ",(0,i.mdx)("inlineCode",{parentName:"p"},"UNSPECIFIED"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"EXACTLY"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"AT_MOST"),"."),(0,i.mdx)("h2",{id:"measuring-a-component"},"Measuring a Component"),(0,i.mdx)("p",null,"A component can be measured in isolation for a given ",(0,i.mdx)("inlineCode",{parentName:"p"},"SizeSpec"),". A ",(0,i.mdx)("inlineCode",{parentName:"p"},"Size")," object, passed as an argument, will be populated with the resulting size."),(0,i.mdx)("p",null,"In the following example, a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Text")," component is measured with unspecified ",(0,i.mdx)("inlineCode",{parentName:"p"},"SizeSpec"),", implying a single line of text indefinitely long."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"final Component<Text> textComponent = Text.create(c)\n    .textSizeSp(16)\n    .text(\u201cSome text to measure.\u201d)\n    .build();\n\nfinal Size outputSize = new Size();\ntextComponent.measure(\n    c,\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    outputSize);\n\nfinal int textComponentWidth = outputSize.width;\nfinal int textComponentHeight = outputSize.height;\n")),(0,i.mdx)("h2",{id:"sizespec-information-during-layout"},"SizeSpec Information During Layout"),(0,i.mdx)("p",null,"During layout creation, the API can provide information about the ",(0,i.mdx)("inlineCode",{parentName:"p"},"SizeSpec"),"s with which the component is going to be measured. To access this information, the ",(0,i.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/annotations/OnCreateLayoutWithSizeSpec.html"},"@OnCreateLayoutWithSizeSpec")," annotation needs to be used instead of ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnCreateLayout"),". The arguments of the annotated method, besides the standard ",(0,i.mdx)("inlineCode",{parentName:"p"},"ComponentContext"),", are two more integers representing the width spec and the height spec."),(0,i.mdx)("p",null,"Similar to Android's ",(0,i.mdx)("inlineCode",{parentName:"p"},"MeasureSpec"),", you can resolve the exact size of a width or height spec integers by using ",(0,i.mdx)("inlineCode",{parentName:"p"},"SizeSpec.getSize(widthSpec)"),", and the mode with ",(0,i.mdx)("inlineCode",{parentName:"p"},"SizeSpec.getMode(widthSpec)"),"."),(0,i.mdx)("p",null,"In the following example, a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Text")," component is measured to check if the given text fits in the available space. An ",(0,i.mdx)("inlineCode",{parentName:"p"},"Image")," component is otherwise used."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/java/documentation/LongTextReplacerComponentSpec.java start=start_example end=end_example",file:"sample/src/main/java/com/facebook/samples/litho/java/documentation/LongTextReplacerComponentSpec.java",start:"start_example",end:"end_example"},'@LayoutSpec\nclass LongTextReplacerComponentSpec {\n\n  @OnCreateLayoutWithSizeSpec\n  static Component onCreateLayoutWithSizeSpec(ComponentContext c, int widthSpec, int heightSpec) {\n\n    final Component textComponent =\n        Text.create(c).textSizeSp(16).text("Some text to measure.").build();\n\n    // UNSPECIFIED sizeSpecs will measure the text as being one line only,\n    // having unlimited width.\n    final Size textOutputSize = new Size();\n    textComponent.measure(\n        c,\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        textOutputSize);\n\n    // Small component to use in case textComponent doesn\u2019t fit within\n    // the current layout.\n    final Component imageComponent = Image.create(c).drawableRes(R.drawable.ic_launcher).build();\n\n    // Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.\n    final int layoutWidth = SizeSpec.getSize(widthSpec);\n    final boolean textFits = (textOutputSize.width <= layoutWidth);\n\n    return textFits ? textComponent : imageComponent;\n  }\n}\n')),(0,i.mdx)("h2",{id:"kotlin-integration"},"Kotlin Integration"),(0,i.mdx)("p",null,"Unfortunately, ",(0,i.mdx)("inlineCode",{parentName:"p"},"KComponent"),"s do not currently support any analogous behaviour of ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnCreateLayoutWithSizeSpec"),". The good news is that such support should be added soon."),(0,i.mdx)("p",null,"For now, if your product requirements demand integration with this API, then the simple workaround would be to define the ",(0,i.mdx)("inlineCode",{parentName:"p"},"KComponent")," with width & height specs as props, then wrap the ",(0,i.mdx)("inlineCode",{parentName:"p"},"KComponent")," in a ",(0,i.mdx)("inlineCode",{parentName:"p"},"LayoutSpec")," with an ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnCreateLayoutWithSizeSpec")," method that delegates the values to your ",(0,i.mdx)("inlineCode",{parentName:"p"},"KComponent"),"."),(0,i.mdx)("p",null,"Following is a ",(0,i.mdx)("inlineCode",{parentName:"p"},"KComponent")," that uses width & height specs as props (based on the Java example above):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/LongTextReplacerKComponent.kt start=start_example end=end_example",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/LongTextReplacerKComponent.kt",start:"start_example",end:"end_example"},'class LongTextReplacerKComponent(private val widthSpec: Int, private val heightSpec: Int) :\n    KComponent() {\n\n  override fun ComponentScope.render(): Component {\n    val textComponent = Text(textSize = 16.sp, text = "Some text to measure")\n\n    val textOutputSize = Size()\n\n    textComponent.measure(\n        context,\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        textOutputSize)\n\n    // Small component to use in case textComponent doesn\u2019t fit within\n    // the current layout.\n    val imageComponent = Image(drawable = drawableRes(R.drawable.ic_launcher))\n\n    // Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.\n    val layoutWidth = SizeSpec.getSize(widthSpec)\n    val textFits = textOutputSize.width <= layoutWidth\n\n    return if (textFits) textComponent else imageComponent\n  }\n}\n')),(0,i.mdx)("p",null,"Following is an example of what a wrapper ",(0,i.mdx)("inlineCode",{parentName:"p"},"LayoutSpec")," would look like that uses this ",(0,i.mdx)("inlineCode",{parentName:"p"},"KComponent"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/LongTextReplacerWrapperComponentSpec.kt start=start_example end=end_example",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/LongTextReplacerWrapperComponentSpec.kt",start:"start_example",end:"end_example"},"@LayoutSpec\nobject LongTextReplacerWrapperComponentSpec {\n\n  @OnCreateLayoutWithSizeSpec\n  fun onCreateLayoutWithSizeSpec(c: ComponentContext, widthSpec: Int, heightSpec: Int): Component {\n    return LongTextReplacerKComponent(widthSpec, heightSpec)\n  }\n}\n")))}u.isMDXComponent=!0}}]);