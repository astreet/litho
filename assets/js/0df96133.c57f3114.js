"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9418],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>m,mdx:()=>y,useMDXComponents:()=>u,withMDXComponents:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),d=function(e){return function(t){var n=u(t.components);return a.createElement(e,i({},t,{components:n}))}},u=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=u(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),m=o,h=d["".concat(r,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});var a=n(67294),o=n(34334);const i="tabItem_Ymn6";function r(e){var t=e.children,n=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,r),hidden:n},t)}},65488:(e,t,n)=>{n.r(t),n.d(t,{default:()=>p});var a=n(83117),o=n(67294),i=n(34334),r=n(72389),s=n(67392),l=n(7094),c=n(12466);const d="tabList__CuJ",u="tabItem_LNqP";function m(e){var t,n,r=e.lazy,m=e.block,p=e.defaultValue,h=e.values,y=e.groupId,f=e.className,b=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=h?h:b.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),v=(0,s.l)(g,(function(e,t){return e.value===t.value}));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var k=null===p?p:null!=(t=null!=p?p:null==(n=b.find((function(e){return e.props.default})))?void 0:n.props.value)?t:b[0].props.value;if(null!==k&&!g.some((function(e){return e.value===k})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var w=(0,l.U)(),x=w.tabGroupChoices,T=w.setTabGroupChoices,C=(0,o.useState)(k),O=C[0],I=C[1],j=[],E=(0,c.o5)().blockElementScrollPositionUntilNextRender;if(null!=y){var _=x[y];null!=_&&_!==O&&g.some((function(e){return e.value===_}))&&I(_)}var N=function(e){var t=e.currentTarget,n=j.indexOf(t),a=g[n].value;a!==O&&(E(t),I(a),null!=y&&T(y,String(a)))},P=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,o=j.indexOf(e.currentTarget)+1;n=null!=(a=j[o])?a:j[0];break;case"ArrowLeft":var i,r=j.indexOf(e.currentTarget)-1;n=null!=(i=j[r])?i:j[j.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,i.Z)("tabs-container",d)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":m},f)},g.map((function(e){var t=e.value,n=e.label,r=e.attributes;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:O===t?0:-1,"aria-selected":O===t,key:t,ref:function(e){return j.push(e)},onKeyDown:P,onFocus:N,onClick:N},r,{className:(0,i.Z)("tabs__item",u,null==r?void 0:r.className,{"tabs__item--active":O===t})}),null!=n?n:t)}))),r?(0,o.cloneElement)(b.filter((function(e){return e.props.value===O}))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},b.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==O})}))))}function p(e){var t=(0,r.default)();return o.createElement(m,(0,a.Z)({key:String(t)},e))}},87913:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>d,default:()=>y,frontMatter:()=>c,metadata:()=>u,toc:()=>p});var a=n(83117),o=n(80102),i=(n(67294),n(3905)),r=n(65488),s=n(85162),l=["components"],c={id:"keys-and-identity",title:"Keys and Component Identity",description:"Explains how Component identity works in Litho using keys and why manual keys are sometimes necessary."},d=void 0,u={unversionedId:"mainconcepts/coordinate-state-actions/keys-and-identity",id:"mainconcepts/coordinate-state-actions/keys-and-identity",title:"Keys and Component Identity",description:"Explains how Component identity works in Litho using keys and why manual keys are sometimes necessary.",source:"@site/../docs/mainconcepts/coordinate-state-actions/keys-and-identity.md",sourceDirName:"mainconcepts/coordinate-state-actions",slug:"/mainconcepts/coordinate-state-actions/keys-and-identity",permalink:"/docs/mainconcepts/coordinate-state-actions/keys-and-identity",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/mainconcepts/coordinate-state-actions/keys-and-identity.md",tags:[],version:"current",frontMatter:{id:"keys-and-identity",title:"Keys and Component Identity",description:"Explains how Component identity works in Litho using keys and why manual keys are sometimes necessary."},sidebar:"mainSidebar",previous:{title:"Flexbox Troubleshooting",permalink:"/docs/mainconcepts/troubleshooting"},next:{title:"Introduction",permalink:"/docs/kotlin/lazycollections/"}},m={},p=[{value:"Automatically assigned keys",id:"automatically-assigned-keys",level:2},{value:"Assigning manual keys",id:"assigning-manual-keys",level:2}],h={toc:p};function y(e){var t=e.components,c=(0,o.Z)(e,l);return(0,i.mdx)("wrapper",(0,a.Z)({},h,c,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Keys help Litho to set a unique identity on a component that represents a node in the component tree. Litho uses keys to keep track of component identity between layout changes and correctly identify a component as the target of a state update."),(0,i.mdx)("p",null,"Based on its type and the key of its parent, Litho automatically sets a key on each component.\nHowever, there are situations when there may be a need to add, remove or rearrange components in the UI, or conditionally add certain components."),(0,i.mdx)("p",null,"This page explains how keys are autogenerated by Litho and why sometimes it's necessary to provide manual keys when they can't be autogenerated."),(0,i.mdx)("p",null,"As long as a component is rendered in the same node in the component tree (see the images, below), it will be assigned the same key. If that node changes position (for example, it's moved to a different parent or it changes position because other sibling nodes are removed or inserted), its key is not guaranteed to be same between UI updates."),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"This is an important consideration because Litho uses the key to determine which component to update when calling a state update and to correctly identify this component when traversing the tree and setting the new state value.")),(0,i.mdx)("h2",{id:"automatically-assigned-keys"},"Automatically assigned keys"),(0,i.mdx)("p",null,"Litho generates component keys based on their type and position relative to the parent, as shown in the folowing Component Tree."),(0,i.mdx)("p",null,(0,i.mdx)("img",{alt:"Tree example",src:n(8862).Z,width:"1582",height:"524"})),(0,i.mdx)("p",null,"The key of a component is a concatenation of the following:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Parent's key")," - when the component is a child."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Component's key")," - determined by its type."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Deduplication ID")," - the position of this component between the other sibling components of the same type.")),(0,i.mdx)("p",null,"To reduce the chance of accidental key collision, there are other separators that are included in the key calculation but, for simplification, they are not included in this example."),(0,i.mdx)("p",null,"The following diagram shows the same Component Tree with added keys."),(0,i.mdx)("p",null,(0,i.mdx)("img",{alt:"Tree example",src:n(65714).Z,width:"1583",height:"524"})),(0,i.mdx)("p",null,"Whenever a key collision is detected in a ComponentTree, which can happen when a parent component created multiple children components of the same type, Litho assigns a unique key to those siblings depending on their order. This means that the keys that are autogenerated are not stable if a component moves its position."),(0,i.mdx)("p",null,"The following diagram shows the Component Tree with the first Row Component removed.\n",(0,i.mdx)("img",{alt:"Tree example",src:n(97602).Z,width:"1583",height:"524"})),(0,i.mdx)("p",null,"After the update, the second Row component in the initial tree is now the first child of type Row, so its key will change!"),(0,i.mdx)("p",null,"Litho was mapping this Row's state to its initial key, so all its state values will be reset after the update. Of greater consequence is that the state for that key will be associated with the next Row component, which is being assigned that key!\nYou can imagine how this can lead to undesirable UI bugs."),(0,i.mdx)("p",null,"Litho key autogeneration is best-effort, but cannot be fully determinist with a runtime implementation."),(0,i.mdx)("h2",{id:"assigning-manual-keys"},"Assigning manual keys"),(0,i.mdx)("p",null,"For dynamic UI hierarchies where components can change position, manual keys that are stable between UI updates must be assigned to components. The manual key will always take precedence over the autogenerated one."),(0,i.mdx)(r.default,{groupId:"keys-and-identity",defaultValue:"kotlin",values:[{label:"Kotlin API",value:"kotlin"},{label:"Spec API",value:"java"}],mdxType:"Tabs"},(0,i.mdx)(s.default,{value:"kotlin",mdxType:"TabItem"},"In the Kotlin API, a manual key can be set via the built-in global `key()` method:",(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/state/IdentityRootComponent.kt start=start_manual_key end=end_manual_key",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/state/IdentityRootComponent.kt",start:"start_manual_key",end:"end_manual_key"},'return Column(\n    style =\n        Style.onVisible {\n          if (!logOnce.value) {\n            // do some logging\n            logOnce.value = true\n          }\n        }) { // end_use_ref\n      if (isFirstCounterEnabled.value) {\n        child(\n            key("first_row") {\n              Row {\n                child(CounterComponent())\n                child(\n                    Text(\n                        text = "X",\n                        textSize = 30.dp,\n                        style =\n                            Style.margin(all = 30.dp).onClick {\n                              isFirstCounterEnabled.update(false)\n                            }))\n              }\n            })\n      }\n'))),(0,i.mdx)(s.default,{value:"java",mdxType:"TabItem"},"In the Spec API, the common `key` component prop can be used to manually set a key when a component is created:",(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/java/identity/IdentityRootComponentSpec.java start=start_manual_key end=end_manual_key",file:"sample/src/main/java/com/facebook/samples/litho/java/identity/IdentityRootComponentSpec.java",start:"start_manual_key",end:"end_manual_key"},'Row.create(c)\n    .key("first_row")\n    .child(CounterComponent.create(c))\n    .child(\n        Text.create(c)\n            .text("X")\n            .clickHandler(IdentityRootComponent.onClickRemoveFirstChild(c)))\n')))),(0,i.mdx)("admonition",{type:"tip"},(0,i.mdx)("p",{parentName:"admonition"},"Setting manual keys is also a nifty way to force a component's state value to be initialised again based on the value of certain props for example, if the manual key is a function of those props.")))}y.isMDXComponent=!0},97602:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/key-tree-remove-child-67e678c6b452ad8294fe5b6dfe06d29f.png"},65714:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/key-tree-with-keys-119162131f591e1d4466c5281abbae65.png"},8862:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/key-tree-51b1340799869efc5ad80723f77692c0.png"}}]);