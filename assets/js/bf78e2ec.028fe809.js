"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1530],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>p,mdx:()=>b,useMDXComponents:()=>u,withMDXComponents:()=>s});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},a.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=o.createContext({}),s=function(e){return function(t){var n=u(t.components);return o.createElement(e,a({},t,{components:n}))}},u=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=u(e.components);return o.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),s=u(n),p=r,f=s["".concat(i,".").concat(p)]||s[p]||m[p]||a;return n?o.createElement(f,c(c({ref:t},d),{},{components:n})):o.createElement(f,c({ref:t},d))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=f;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var d=2;d<a;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},28222:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>c,metadata:()=>d,toc:()=>u});var o=n(83117),r=n(80102),a=(n(67294),n(3905)),i=["components"],c={id:"introduction-to-rendercore",title:"Introduction to RenderCore"},l=void 0,d={unversionedId:"mountablecomponents/introduction-to-rendercore",id:"mountablecomponents/introduction-to-rendercore",title:"Introduction to RenderCore",description:"RenderCore is an abstract framework that is agnostic of the user-facing APIs. RenderCore implements a rendering pipeline for Components-based UI frameworks that provides client frameworks with the capability to compute layouts ahead of time in the background and render them efficiently. Litho uses RenderCore to render Mountable Components.",source:"@site/../docs/mountablecomponents/introduction-to-rendercore.mdx",sourceDirName:"mountablecomponents",slug:"/mountablecomponents/introduction-to-rendercore",permalink:"/docs/mountablecomponents/introduction-to-rendercore",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/mountablecomponents/introduction-to-rendercore.mdx",tags:[],version:"current",frontMatter:{id:"introduction-to-rendercore",title:"Introduction to RenderCore"}},s={},u=[{value:"RenderUnit",id:"renderunit",level:2},{value:"ContentAllocator",id:"contentallocator",level:2},{value:"Binder",id:"binder",level:2}],p={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.mdx)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"RenderCore is an abstract framework that is agnostic of the user-facing APIs. RenderCore implements a rendering pipeline for Components-based UI frameworks that provides client frameworks with the capability to compute layouts ahead of time in the background and render them efficiently. Litho uses RenderCore to render Mountable Components."),(0,a.mdx)("p",null,"While it\u2019s not necessary to understand how RenderCore works under the hood in order to implement Mountable Components, familiarizing yourself with the basic RenderCore concepts introduced on this page is important to be able to implement a Mountable (a reusable building block hosted by each Mountable Component)."),(0,a.mdx)("h2",{id:"renderunit"},"RenderUnit"),(0,a.mdx)("p",null,"A RenderUnit represents a single rendering primitive for RenderCore. It encapsulates information about the content (view or drawable) to be mounted, and how to set and unset properties on that content using Binders (see below)."),(0,a.mdx)("p",null,"Every RenderUnit has to define at least a createContent method to allocate the content via the ContentAllocator it returns from the getContentAllocator method (see below)."),(0,a.mdx)("p",null,"Mountable extends RenderUnit."),(0,a.mdx)("h2",{id:"contentallocator"},"ContentAllocator"),(0,a.mdx)("p",null,"A ContentAllocator defines a class that can provide mountable content and have that content pooled. In order to optimize mount performance, implementations can override content pooling methods."),(0,a.mdx)("p",null,"Each Mountable needs to return a ContentAllocator implementation from its getContentAllocator method."),(0,a.mdx)("h2",{id:"binder"},"Binder"),(0,a.mdx)("p",null,"A Binder is an interface that specifies how to set and unset properties on the mounted content."),(0,a.mdx)("p",null,"Each Mountable can host one or more Binders."))}m.isMDXComponent=!0}}]);